<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>TranscodingStreams.jl · TranscodingStreams.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>TranscodingStreams.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">TranscodingStreams.jl</a><ul class="internal"><li><a class="toctext" href="#Introduction-1">Introduction</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#API-1">API</a></li><li><a class="toctext" href="#Defining-a-new-codec-1">Defining a new codec</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">TranscodingStreams.jl</a></li></ul><a class="edit-page" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>TranscodingStreams.jl</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="TranscodingStreams.jl-1" href="#TranscodingStreams.jl-1">TranscodingStreams.jl</a></h1><p>TranscodingStreams.jl is a package for transcoding (e.g. compression) data streams. This package exports a type <code>TranscodingStream</code>, which is a subtype of <code>IO</code> and supports various I/O operations like other usual I/O streams in the standard library.</p><h2><a class="nav-anchor" id="Introduction-1" href="#Introduction-1">Introduction</a></h2><p><code>TranscodingStream</code> has two type parameters, <code>C&lt;:Codec</code> and <code>S&lt;:IO</code>, and hence the actual type should be written as <code>TranscodingStream{C&lt;:Codec,S&lt;:IO}</code>. This type wraps an underlying I/O stream <code>S</code> by a codec <code>C</code>. The codec defines transformation (or transcoding) of the stream. For example, when <code>C</code> is a lossless decompression type and <code>S</code> is a file, <code>TranscodingStream{C,S}</code> behaves like a data stream that incrementally decompresses data from the file.</p><p>Codecs are defined in other packages listed below:</p><table>
    <tr>
        <th>Package</th>
        <th>Library</th>
        <th>Format</th>
        <th>Codec</th>
        <th>Stream</th>
        <th>Description</th>
    </tr>
    <tr>
        <td rowspan="6"><a href="https://github.com/bicycle1885/CodecZlib.jl">CodecZlib.jl</a></td>
        <td rowspan="6"><a href="http://zlib.net/">zlib</a></td>
        <td rowspan="2"><a href="https://tools.ietf.org/html/rfc1952">RFC1952</a></td>
        <td><code>GzipCompression</code></td>
        <td><code>GzipCompressionStream</code></td>
        <td>Compress data in gzip (.gz) format.</td>
    </tr>
    <tr>
        <td><code>GzipDecompression</code></td>
        <td><code>GzipDecompressionStream</code></td>
        <td>Decompress data in gzip (.gz) format.</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="https://tools.ietf.org/html/rfc1950">RFC1950</a></td>
        <td><code>ZlibCompression</code></td>
        <td><code>ZlibCompressionStream</code></td>
        <td>Compress data in zlib format.</td>
    </tr>
    <tr>
        <td><code>ZlibDecompression</code></td>
        <td><code>ZlibDecompressionStream</code></td>
        <td>Decompress data in zlib format.</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="https://tools.ietf.org/html/rfc1951">RFC1951</a></td>
        <td><code>DeflateCompression</code></td>
        <td><code>DeflateCompressionStream</code></td>
        <td>Compress data in deflate format.</td>
    </tr>
    <tr>
        <td><code>DeflateDecompression</code></td>
        <td><code>DeflateDecompressionStream</code></td>
        <td>Decompress data in deflate format.</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="https://github.com/bicycle1885/CodecBzip2.jl">CodecBzip2.jl</a></td>
        <td rowspan="2"><a href="http://www.bzip.org/">bzip2</a></td>
        <td rowspan="2"></td>
        <td><code>Bzip2Compression</code></td>
        <td><code>Bzip2CompressionStream</code></td>
        <td>Compress data in bzip2 (.bz2) format.</td>
    </tr>
    <tr>
        <td><code>Bzip2Decompression</code></td>
        <td><code>Bzip2DecompressionStream</code></td>
        <td>Decompress data in bzip2 (.bz2) format.</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="https://github.com/bicycle1885/CodecXz.jl">CodecXz.jl</a></td>
        <td rowspan="2"><a href="https://tukaani.org/xz/">xz</a></td>
        <td rowspan="2"><a href="https://tukaani.org/xz/xz-file-format.txt">The .xz File Format</a></td>
        <td><code>XzCompression</code></td>
        <td><code>XzCompressionStream</code></td>
        <td>Compress data in xz (.xz) format.</td>
    </tr>
    <tr>
        <td><code>XzDecompression</code></td>
        <td><code>XzDecompressionStream</code></td>
        <td>Decompress data in xz (.xz) format.</td>
    </tr>
    <tr>
        <td rowspan="2"><a href="https://github.com/bicycle1885/CodecZstd.jl">CodecZstd.jl</a></td>
        <td rowspan="2"><a href="http://facebook.github.io/zstd/">zstd</a></td>
        <td rowspan="2"><a href="https://github.com/facebook/zstd/blob/dev/doc/zstd_compression_format.md">Zstandard Compression Format</a></td>
        <td><code>ZstdCompression</code></td>
        <td><code>ZstdCompressionStream</code></td>
        <td>Compress data in zstd (.zst) format.</td>
    </tr>
    <tr>
        <td><code>ZstdDecompression</code></td>
        <td><code>ZstdDecompressionStream</code></td>
        <td>Decompress data in zstd (.zst) format.</td>
    </tr>
</table><p>Install packages you need by calling <code>Pkg.add(&lt;package name&gt;)</code> in a Julia session. For example, if you want to read gzip-compressed files, call <code>Pkg.add(&quot;CodecZlib&quot;)</code> to use <code>GzipDecompression</code> or <code>GzipDecompressionStream</code>. By convention, codec types have a name that matches <code>.*(Co|Deco)mpression</code> and I/O types have a codec name with <code>Stream</code> suffix. All codecs are a subtype <code>TranscodingStreams.Codec</code> and streams are a subtype of <code>Base.IO</code>. An important thing is these packages depend on TranscodingStreams.jl and not <em>vice versa</em>. This means you can install any codec package you need without installing all codec packages.  Also, if you want to define your own codec, it is totally feasible like these packages.  TranscodingStreams.jl requests a codec to implement some interface functions which will be described later.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><h3><a class="nav-anchor" id="Read-lines-from-a-gzip-compressed-file-1" href="#Read-lines-from-a-gzip-compressed-file-1">Read lines from a gzip-compressed file</a></h3><p>The following snippet is an example of using CodecZlib.jl, which exports <code>GzipDecompressionStream{S}</code> as an alias of <code>TranscodingStream{GzipDecompression,S} where S&lt;:IO</code>:</p><pre><code class="language-julia">using CodecZlib
stream = GzipDecompressionStream(open(&quot;data.txt.gz&quot;))
for line in eachline(stream)
    # do something...
end
close(stream)</code></pre><p>Note that the last <code>close</code> call will close the file as well.  Alternatively, <code>open(&lt;stream type&gt;, &lt;filepath&gt;) do ... end</code> syntax will close the file at the end:</p><pre><code class="language-julia">using CodecZlib
open(GzipDecompressionStream, &quot;data.txt.gz&quot;) do stream
    for line in eachline(stream)
        # do something...
    end
end</code></pre><h3><a class="nav-anchor" id="Save-a-data-matrix-with-Zstd-compression-1" href="#Save-a-data-matrix-with-Zstd-compression-1">Save a data matrix with Zstd compression</a></h3><p>Writing compressed data is easy. One thing you need to keep in mind is to call <code>close</code> after writing data; otherwise, the output file will be incomplete:</p><pre><code class="language-julia">using CodecZstd
mat = randn(100, 100)
stream = ZstdCompressionStream(open(&quot;data.mat.zst&quot;, &quot;w&quot;))
writedlm(stream, mat)
close(stream)</code></pre><p>Of course, <code>open(&lt;stream type&gt;, ...) do ... end</code> works well:</p><pre><code class="language-julia">using CodecZstd
mat = randn(100, 100)
open(ZstdCompressionStream, &quot;data.mat.zst&quot;, &quot;w&quot;) do stream
    writedlm(stream, mat)
end</code></pre><h3><a class="nav-anchor" id="Explicitly-finish-transcoding-by-writing-TOKEN_END-1" href="#Explicitly-finish-transcoding-by-writing-TOKEN_END-1">Explicitly finish transcoding by writing <code>TOKEN_END</code></a></h3><p>When writing data, the end of a data stream is indicated by calling <code>close</code>, which may write an epilogue if necessary and flush all buffered data to the underlying I/O stream. If you want to explicitly specify the end position of a stream for some reason, you can write <code>TranscodingStreams.TOKEN_END</code> to the transcoding stream as follows:</p><pre><code class="language-julia">using CodecZstd
using TranscodingStreams
buf = IOBuffer()
stream = ZstdCompressionStream(buf)
write(stream, &quot;foobarbaz&quot;^100, TranscodingStreams.TOKEN_END)
flush(stream)
compressed = take!(buf)
close(stream)</code></pre><h3><a class="nav-anchor" id="Use-a-noop-codec-1" href="#Use-a-noop-codec-1">Use a noop codec</a></h3><p>Sometimes, the <code>Noop</code> codec, which does nothing, may be useful. The following example creates a decompression stream based on the extension of a filepath:</p><pre><code class="language-julia">using CodecZlib
using CodecBzip2
using TranscodingStreams

function makestream(filepath)
    if endswith(filepath, &quot;.gz&quot;)
        codec = GzipDecompression()
    elseif endswith(filepath, &quot;.bz2&quot;)
        codec = Bzip2Decompression()
    else
        codec = Noop()
    end
    return TranscodingStream(codec, open(filepath))
end

makestream(&quot;data.txt.gz&quot;)
makestream(&quot;data.txt.bz2&quot;)
makestream(&quot;data.txt&quot;)</code></pre><h3><a class="nav-anchor" id="Transcode-data-in-one-shot-1" href="#Transcode-data-in-one-shot-1">Transcode data in one shot</a></h3><p>TranscodingStreams.jl extends the <code>transcode</code> function to transcode a data in one shot. <code>transcode</code> takes a codec object as its first argument and a data vector as its second argument:</p><pre><code class="language-julia">using CodecZlib
decompressed = transcode(ZlibDecompression(), b&quot;x\x9cKL*JLNLI\x04R\x00\x19\xf2\x04U&quot;)
String(decompressed)</code></pre><h2><a class="nav-anchor" id="API-1" href="#API-1">API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.TranscodingStream-Tuple{TranscodingStreams.Codec,IO}" href="#TranscodingStreams.TranscodingStream-Tuple{TranscodingStreams.Codec,IO}"><code>TranscodingStreams.TranscodingStream</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">TranscodingStream(codec::Codec, stream::IO; bufsize::Integer=16384)</code></pre><p>Create a transcoding stream with <code>codec</code> and <code>stream</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using TranscodingStreams

julia&gt; using CodecZlib

julia&gt; file = open(Pkg.dir(&quot;TranscodingStreams&quot;, &quot;test&quot;, &quot;abra.gzip&quot;));

julia&gt; stream = TranscodingStream(GzipDecompression(), file)
TranscodingStreams.TranscodingStream{CodecZlib.GzipDecompression,IOStream}(&lt;state=idle&gt;)

julia&gt; readstring(stream)
&quot;abracadabra&quot;
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/stream.jl#L40-L62">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.transcode-Tuple{TranscodingStreams.Codec,Array{UInt8,1}}" href="#Base.transcode-Tuple{TranscodingStreams.Codec,Array{UInt8,1}}"><code>Base.transcode</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">transcode(codec::Codec, data::Vector{UInt8})::Vector{UInt8}</code></pre><p>Transcode <code>data</code> by applying <code>codec</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; using CodecZlib

julia&gt; data = Vector{UInt8}(&quot;abracadabra&quot;);

julia&gt; compressed = transcode(ZlibCompression(), data);

julia&gt; decompressed = transcode(ZlibDecompression(), compressed);

julia&gt; String(decompressed)
&quot;abracadabra&quot;
</code></pre></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/stream.jl#L293-L314">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.TOKEN_END" href="#TranscodingStreams.TOKEN_END"><code>TranscodingStreams.TOKEN_END</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>A special token indicating the end of data.</p><p><code>TOKEN_END</code> may be written to a transcoding stream like <code>write(stream, TOKEN_END)</code>, which will terminate the current transcoding block.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Call <code>flush(stream)</code> after <code>write(stream, TOKEN_END)</code> to make sure that all data are written to the underlying stream.</p></div></div></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/stream.jl#L270-L280">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.Noop" href="#TranscodingStreams.Noop"><code>TranscodingStreams.Noop</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Noop()</code></pre><p>Create a noop codec.</p><p>Noop (no operation) is a codec that does nothing. The data read from or written to the stream are kept as-is without any modification. This is often useful as a buffered stream or an identity element of a composition of streams.</p><p>The implementations are specialized for this codec. For example, a <code>Noop</code> stream uses only one buffer rather than a pair of buffers, which avoids copying data between two buffers and the throughput will be larger than a naive implementation.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/noop.jl#L4-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.NoopStream" href="#TranscodingStreams.NoopStream"><code>TranscodingStreams.NoopStream</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">NoopStream(stream::IO)</code></pre><p>Create a noop stream.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/noop.jl#L22-L26">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.CodecIdentity.Identity" href="#TranscodingStreams.CodecIdentity.Identity"><code>TranscodingStreams.CodecIdentity.Identity</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Identity()</code></pre><p>Create an identity (no-op) codec.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/identity.jl#L15-L19">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.CodecIdentity.IdentityStream" href="#TranscodingStreams.CodecIdentity.IdentityStream"><code>TranscodingStreams.CodecIdentity.IdentityStream</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">IdentityStream(stream::IO)</code></pre><p>Create an identity (no-op) stream.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/identity.jl#L24-L28">source</a><br/></section><h2><a class="nav-anchor" id="Defining-a-new-codec-1" href="#Defining-a-new-codec-1">Defining a new codec</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.Codec" href="#TranscodingStreams.Codec"><code>TranscodingStreams.Codec</code></a> — <span class="docstring-category">Type</span>.</div><div><p>An abstract codec type.</p><p>Any codec supporting the transcoding protocol must be a subtype of this type.</p><p><strong>Transcoding protocol</strong></p><p>Transcoding proceeds by calling some functions in a specific way. We call this &quot;transcoding protocol&quot; and any codec must implement it as described below.</p><p>There are four functions for a codec to implement:</p><ul><li><p>initialize: initialize the codec</p></li><li><p>finalize: finalize the codec</p></li><li><p>startproc: start processing with the codec</p></li><li><p>process: process data with the codec.</p></li></ul><p>These are defined in the <code>TranscodingStreams</code> and a new codec type must extend these methods if necessary.  Implementing a <code>process</code> method is mandatory but other three are optional.  <code>initialize</code>, <code>finalize</code>, and <code>startproc</code> have a default implementation that does nothing.</p><p>Your codec type is denoted by <code>C</code> and its object by <code>codec</code>.</p><p>The <code>initialize(codec::C)::Void</code> method takes <code>codec</code> and returns <code>nothing</code>. This is called once and only once before starting any data processing.  Therefore, you may initialize <code>codec</code> (e.g. allocating memory needed to process data) with this method. If initialization fails for some reason, it may throw an exception and no other methods will be called.</p><p>The <code>finalize(codec::C)::Void</code> method takes <code>codec</code> and returns <code>nothing</code>.  This is called when and only when the transcoding stream goes to the close state (i.e. when <code>Base.close</code> is called). Therefore, you may finalize <code>codec</code> (e.g. freeing memory) with this method. If finalization fails for some reason, it may throw an exception. Even when an exception is thrown while finalizing a stream, the stream will become the close state for safety.</p><p>The <code>startproc(codec::C, state::Symbol)::Symbol</code> method takes <code>codec</code> and <code>state</code>, and returns a status code. This is called just before the stream starts reading or writing data. <code>state</code> is either <code>:read</code> or <code>:write</code> and then the stream starts reading or writing, respectively. The return code must be <code>:ok</code> if <code>codec</code> is ready to read or write data. Otherwise, it should be <code>:fail</code> and then the stream throws an exception.</p><p>The <code>process(codec::C, input::Memory, output::Memory)::Tuple{Int,Int,Symbol}</code> method takes <code>codec</code>, <code>input</code> and <code>output</code>, and returns a consumed data size, a produced data size and a status code. This is called repeatedly while processing data. The input (<code>input</code>) and output (<code>output</code>) data are a <code>Memory</code> object, which is a pointer to a contiguous memory region with size. You must read input data from <code>input</code>, transcode the bytes, and then write the output data to <code>output</code>.  Finally you need to return the size of read data, the size of written data, and <code>:ok</code> status code so that the caller can know how many bytes are consumed and produced in the method.  When transcoding reaches the end of a data stream, it is notified to this method by empty input. In that case, the method need to write the buffered data (if any) to <code>output</code>. If there is no data to write, the status code must be set to <code>:end</code>. The <code>process</code> method will be called repeatedly until it returns <code>:end</code> status code.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/codec.jl#L4-L63">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.initialize" href="#TranscodingStreams.initialize"><code>TranscodingStreams.initialize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">initialize(codec::Codec)::Void</code></pre><p>Initialize <code>codec</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/codec.jl#L70-L74">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.finalize" href="#TranscodingStreams.finalize"><code>TranscodingStreams.finalize</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">finalize(codec::Codec)::Void</code></pre><p>Finalize <code>codec</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/codec.jl#L79-L83">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.startproc" href="#TranscodingStreams.startproc"><code>TranscodingStreams.startproc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">startproc(codec::Codec, state::Symbol)::Symbol</code></pre><p>Start data processing with <code>codec</code> of <code>state</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/codec.jl#L88-L92">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.process" href="#TranscodingStreams.process"><code>TranscodingStreams.process</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">process(codec::Codec, input::Memory, output::Memory)::Tuple{Int,Int,Symbol}</code></pre><p>Do data processing with <code>codec</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/codec.jl#L97-L101">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TranscodingStreams.Memory" href="#TranscodingStreams.Memory"><code>TranscodingStreams.Memory</code></a> — <span class="docstring-category">Type</span>.</div><div><p>A contiguous memory.</p><p>This type works like a <code>Vector</code> method.</p></div><a class="source-link" target="_blank" href="https://github.com/bicycle1885/TranscodingStreams.jl/tree/c4531340178ecd08f036605fd53c88c36a7bd7c4/src/memory.jl#L4-L8">source</a><br/></section><footer><hr/></footer></article></body></html>
